import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Worker, WorkerFormData, QRCode, WorkerStatus } from '@/types/worker';
import { toast } from 'sonner';

export function useWorkers(filters?: {
  search?: string;
  status?: WorkerStatus | 'all';
  department?: string;
}) {
  return useQuery({
    queryKey: ['workers', filters],
    queryFn: async () => {
      let query = supabase
        .from('workers')
        .select('*, qr_codes(*)')
        .is('deleted_at', null)
        .order('created_at', { ascending: false });

      if (filters?.search) {
        query = query.or(`first_name.ilike.%${filters.search}%,last_name.ilike.%${filters.search}%,cedula.ilike.%${filters.search}%,internal_id.ilike.%${filters.search}%`);
      }

      if (filters?.status && filters.status !== 'all') {
        query = query.eq('status', filters.status);
      }

      if (filters?.department) {
        query = query.eq('department', filters.department);
      }

      const { data, error } = await query;

      if (error) throw error;
      return data as (Worker & { qr_codes: QRCode[] })[];
    },
  });
}

export function useWorker(id: string) {
  return useQuery({
    queryKey: ['worker', id],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('workers')
        .select('*, qr_codes(*)')
        .eq('id', id)
        .maybeSingle();

      if (error) throw error;
      return data as (Worker & { qr_codes: QRCode[] }) | null;
    },
    enabled: !!id,
  });
}

export function useCreateWorker() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (formData: WorkerFormData & { photo_url?: string }) => {
      const { data: { user } } = await supabase.auth.getUser();
      
      const { data, error } = await supabase
        .from('workers')
        .insert({
          first_name: formData.first_name,
          last_name: formData.last_name,
          cedula: formData.cedula,
          photo_url: formData.photo_url || null,
          position: formData.position,
          department: formData.department,
          phone: formData.phone || null,
          email: formData.email || null,
          status: formData.status,
          valid_from: formData.valid_from,
          valid_until: formData.valid_until,
          created_by: user?.id,
          internal_id: '', // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (error) throw error;

      // Log audit
      await supabase.from('audit_logs').insert({
        action: 'CREATE',
        table_name: 'workers',
        record_id: data.id,
        new_data: data,
        performed_by: user?.id,
      });

      return data as Worker;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['workers'] });
      toast.success('Trabajador registrado exitosamente');
    },
    onError: (error: Error) => {
      toast.error(`Error al registrar: ${error.message}`);
    },
  });
}

export function useUpdateWorker() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, ...formData }: Partial<WorkerFormData> & { id: string; photo_url?: string }) => {
      const { data: { user } } = await supabase.auth.getUser();
      
      const { data: oldData } = await supabase
        .from('workers')
        .select()
        .eq('id', id)
        .single();

      const { data, error } = await supabase
        .from('workers')
        .update({
          first_name: formData.first_name,
          last_name: formData.last_name,
          cedula: formData.cedula,
          photo_url: formData.photo_url,
          position: formData.position,
          department: formData.department,
          phone: formData.phone || null,
          email: formData.email || null,
          status: formData.status,
          valid_from: formData.valid_from,
          valid_until: formData.valid_until,
        })
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;

      // Log audit
      await supabase.from('audit_logs').insert({
        action: 'UPDATE',
        table_name: 'workers',
        record_id: id,
        old_data: oldData,
        new_data: data,
        performed_by: user?.id,
      });

      return data as Worker;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['workers'] });
      toast.success('Trabajador actualizado exitosamente');
    },
    onError: (error: Error) => {
      toast.error(`Error al actualizar: ${error.message}`);
    },
  });
}

export function useDeleteWorker() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      const { data: { user } } = await supabase.auth.getUser();
      
      const { data: oldData } = await supabase
        .from('workers')
        .select()
        .eq('id', id)
        .single();

      const { error } = await supabase
        .from('workers')
        .update({ deleted_at: new Date().toISOString() })
        .eq('id', id);

      if (error) throw error;

      // Revoke all QR codes
      await supabase
        .from('qr_codes')
        .update({ is_revoked: true, revoked_at: new Date().toISOString() })
        .eq('worker_id', id);

      // Log audit
      await supabase.from('audit_logs').insert({
        action: 'DELETE',
        table_name: 'workers',
        record_id: id,
        old_data: oldData,
        performed_by: user?.id,
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['workers'] });
      toast.success('Trabajador dado de baja exitosamente');
    },
    onError: (error: Error) => {
      toast.error(`Error al eliminar: ${error.message}`);
    },
  });
}

export function useGenerateQR() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (workerId: string) => {
      const { data: { user } } = await supabase.auth.getUser();
      
      // Generate secure token
      const { data: tokenData, error: tokenError } = await supabase
        .rpc('generate_qr_token');

      if (tokenError) throw tokenError;

      const { data, error } = await supabase
        .from('qr_codes')
        .insert({
          worker_id: workerId,
          token: tokenData,
          created_by: user?.id,
        })
        .select()
        .single();

      if (error) throw error;

      // Log audit
      await supabase.from('audit_logs').insert({
        action: 'GENERATE_QR',
        table_name: 'qr_codes',
        record_id: data.id,
        new_data: data,
        performed_by: user?.id,
      });

      return data as QRCode;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['workers'] });
      toast.success('Código QR generado exitosamente');
    },
    onError: (error: Error) => {
      toast.error(`Error al generar QR: ${error.message}`);
    },
  });
}

export function useRevokeQR() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (qrId: string) => {
      const { data: { user } } = await supabase.auth.getUser();
      
      const { error } = await supabase
        .from('qr_codes')
        .update({ is_revoked: true, revoked_at: new Date().toISOString() })
        .eq('id', qrId);

      if (error) throw error;

      // Log audit
      await supabase.from('audit_logs').insert({
        action: 'REVOKE_QR',
        table_name: 'qr_codes',
        record_id: qrId,
        performed_by: user?.id,
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['workers'] });
      toast.success('Código QR revocado exitosamente');
    },
    onError: (error: Error) => {
      toast.error(`Error al revocar QR: ${error.message}`);
    },
  });
}

export function useDepartments() {
  return useQuery({
    queryKey: ['departments'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('workers')
        .select('department')
        .is('deleted_at', null);

      if (error) throw error;

      const departments = [...new Set(data.map(w => w.department))];
      return departments.filter(Boolean).sort();
    },
  });
}

export function useUploadPhoto() {
  return useMutation({
    mutationFn: async (file: File) => {
      const fileExt = file.name.split('.').pop();
      const fileName = `${crypto.randomUUID()}.${fileExt}`;
      const filePath = `photos/${fileName}`;

      const { error: uploadError } = await supabase.storage
        .from('worker-photos')
        .upload(filePath, file);

      if (uploadError) throw uploadError;

      const { data } = supabase.storage
        .from('worker-photos')
        .getPublicUrl(filePath);

      return data.publicUrl;
    },
  });
}
